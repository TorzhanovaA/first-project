<!DOCTYPE html>
	<html>
	<title>АРХИТЕКТУРА</title>
	</head>
	<body>
		<h1>2 АРХИТЕКТУРА</h1>
			<p>В этом разделе мы рассмотрим элементы паттерна Ports & Adapters и связи между ними.</p>
		<h1>2.1. ГЕКСАГОН</h1>
			<p>Паттерн Ports & Adapters изображает приложение в виде замкнутой области. </p>
 			<p>Замкнутая область, выбранная Алистером Кокберном для рисования приложения, представляла собой гексагон, поэтому этот паттерн также называют гексагональной архитектурой.</p>
			<p>Лично мне больше нравится название Ports and Adapters, потому что оно относится к ключевым элементам архитектуры, как мы скоро увидим. С другой стороны, фигура, которую вы используете для рисования приложения, не важна. Однако, похоже, что более популярным является название Hexagonal Architecture.</p>
			<p>Гексагон - это само приложение. Говорить "гексагон" и говорить "приложение" - одно и то же, с этого момента эти термины будут использоваться нераздельно </p>
			<p>Внутри гексагона находятся только те вещи, которые важны для решения бизнес-задачи, которую пытается решить приложение.
			<p>Гексагон содержит бизнес-логику, без ссылок на какие-либо технологии, фреймворки или устройства реального мира. Таким образом, приложение не зависит от технологии.</p>
			<p>Шаблон Ports & Adapters ничего не говорит о структуре внутренней части гексагона. Вы можете иметь слои... вы можете иметь компоненты по функциям... вы можете иметь спагетти-код... вы можете иметь большой ком грязи... вы можете применять тактические паттерны DDD... вы можете иметь единый CRUD... все зависит от вас.</p>
		<h1>2.2 АКТОРЫ</h1>
			<p> За пределами гексагона находятся все объекты реального мира, с которыми взаимодействует приложение. Эти вещи включают людей, другие приложения или любое аппаратное/программное устройство. Они являются действующими лицами. Можно сказать, что акторы - это среда приложения.</p>
			<p>Акторы располагаются вокруг гексагона в зависимости от того, кто инициирует взаимодействие между приложением и актором:</p>
			<p>Акторы с левой/верхней стороны - это управляющие или первичные акторы. Взаимодействие запускается актором. Драйвер - это агент, который взаимодействует с приложением для достижения цели. Драйверы - это пользователи (люди или устройства) приложения.</p>
			<p>Акторы с правой/нижней стороны - это управляемые или вторичные акторы. Взаимодействие инициируется приложением. Управляемый агент предоставляет некоторую функциональность, необходимую приложению для реализации бизнес-логики.</p>
			<p>Существует два вида управляемых акторов:</p>
			<p>Репозиторий: Приложение может не только отправлять, но и получать из него информацию. Например, база данных или любое другое устройство хранения.</p>
			<p>Получатель: Приложение просто отправляет ему информацию и забывает о ней. Например, SMTP-сервер для отправки электронной почты.</p>
			<p>На следующем рисунке показаны некоторые примеры действующих лиц как со стороны драйверов, так и со стороны драйверов:</p>
	<center> <img src="img_1.jpeg"> </center>
	        <p><center>Рисунок 1: Акторы</center></p>
	        <p>Эти концепции первичных (управляющих) и вторичных (управляемых) акторов вызывают примеры использования.</p>
	        <p>Итак, чтобы узнать, какой актор является действующим лицом во взаимодействии приложения и актора, спросите себя "кто" вызывает разговор. Если ответ "актор", то это управляющий актор. Если ответ - "приложение", то актор управляемый.</p>
		<h1>2.3. ПОРТЫ</h1>
			<p>Взаимодействия между субъектами и приложением организуются на границе гексагона по причине, по которой они взаимодействуют с приложением. Каждая группа взаимодействий с определенной целью/намерением является портом.</p>
			<p>Порты должны называться в соответствии с тем, для чего они предназначены, а не в соответствии с какой-либо технологией. Поэтому, чтобы назвать порт, мы должны использовать глагол, оканчивающийся на "ing", и сказать: "Этот порт предназначен для ...ing чего-то". Например:</p>
<ul>
	<li>Этот управляющий порт предназначен для "добавления товаров в корзину".</li>
	<li>Этот управляемый порт (хранилище) предназначен "для получения информации о заказах".
</li>
<li>Этот управляемый порт (получатель) предназначен для "отправки уведомлений".
</li>
</ul>
			<p>Порты - это граница приложения, на рисунке порт - это ребро гексагона. Из внешнего мира агенты могут взаимодействовать только с портами гексагона, они не должны иметь доступ к внутренней части гексагона. Порты - это интерфейсы, которые приложение предлагает внешнему миру для того, чтобы акторы могли взаимодействовать с приложением. Поэтому приложение должно следовать принципу сокрытия информации. Важно отметить, что порты принадлежат приложению.
</p>
			<p>Порты драйвера предлагают функциональность приложения драйверам внешнего мира. Таким образом, считается, что порты драйвера являются границей сценария использования приложения. Они являются API приложения.
</p>
			<p>В зависимости от гранулярности, которую мы применяем при группировке функциональности, мы можем иметь интерфейс порта со многими вариантами использования или всего с несколькими. Если мы хотим следовать принципу единой ответственности, то у нас будет много портов, каждый из которых предназначен для одного варианта использования. В этом случае лучшим вариантом будет применение шаблона проектирования шины команд к порту, с обработчиком команд для каждого случая использования. Та же идея может быть применена к запросам, чтобы мы также удовлетворяли шаблону CQRS. У нас будет порт для выполнения команд и другой порт для выполнения запросов.
</p>
			<p>Управляемый порт - это интерфейс для функциональности, необходимой приложению для реализации бизнес-логики. Такая функциональность предоставляется управляемым актором. Таким образом, управляемые порты - это интерфейс SPI (Service Provider Interface), необходимый приложению. Управляемый порт похож на требуемый интерфейс (зависимость без которой приложение работать не может).
</p>
		<h1>2.4. АДАПТЕРЫ</h1>
			<p>Акторы взаимодействуют с портами гексагона через адаптеры, используя определенную технологию. Адаптер - это программный компонент, который позволяет технологии взаимодействовать с портом гексагона. Для каждого порта может существовать адаптер для каждой технологии, которую мы хотим использовать. Адаптеры находятся за пределами приложения.</p>
			<p>Адаптер драйвера использует интерфейс порта драйвера, преобразуя запрос конкретной технологии в запрос к порту драйвера, не зависящий от технологии.</p>
			<p>На рисунке 2 показаны некоторые примеры адаптеров драйверов:</p>
		<center> <img src="img_2.jpeg"> </center>
	        <p><center>Рисунок 2: Управляющие адаптеры</center></p>
	 <ul>
		<li>Фреймворк для автоматизированного тестирования: преобразует тестовые случаи в запросы к порту драйвера.</li>
		<li>ЭCLI (интерфейс командной строки): преобразует текст, введенный в консоли.</li>
		<li>Графический интерфейс настольного приложения: преобразование событий, вызванных графическими компонентами.</li>
		<li>Веб-приложение MVC: контроллер получает от представления действие, запрашиваемое пользователем, и преобразует его в запрос к порту драйвера.</li>
		<li>Контроллер REST API: преобразует запросы REST API.</li>
		<li>Подписчик событий: преобразует сообщения (события) из очереди сообщений, на которую подписано приложение.</li>
</ul>
			<p>Для каждого порта драйвера должно быть как минимум два адаптера: один для реального драйвера, который будет его выполнять, а другой - для тестирования поведения порта.</p>
			<p>Управляемый адаптер реализует интерфейс управляемого порта, преобразуя методы порта, не зависящие от технологии, в методы конкретной технологии.</p>
			<p>Некоторые примеры управляемых адаптеров показаны на рисунке:</p>
		<center> <img src="img_3.jpeg"> </center>
	        <p><center>Рисунок 3: Управляемые адаптеры</center></p>
	<ul>
		<li>Адаптер-имитатор: он имитирует поведение реального вторичного агента, например, базы данных inmemory.</li>
		<li>Адаптер SQL: реализует управляемый порт для сохранения данных путем доступа к базе данных SQL.</li>
		<li>Адаптер электронной почты: реализует управляемый порт для уведомления людей путем отправки им электронного письма.</li>
		<li>Адаптер App-To-App: реализует управляемый порт для получения некоторых данных путем запроса их в удаленное приложение.</li>
		<li>Издатель событий: реализует управляемый порт для публикации событий путем отправки их в очередь сообщений, чтобы они были доступны для подписчиков.</li>
</ul> 
			<p>Для каждого управляемого порта мы должны написать как минимум два адаптера: один для реального устройства, а другой - имитатор, имитирующий реальное поведение.</p>   
			<p>В конечном итоге адаптер преобразует один интерфейс в другой, поэтому для его реализации мы можем использовать паттерн проектирования адаптера.</p>
			<p>Какой адаптер использовать для каждого порта - это то, что настраивается при запуске приложения. Именно это придает гибкость данному паттерну, так что мы можем переключаться с одной технологии на другую каждый раз, когда запускаем приложение. Если мы выбираем тестовый драйвер и подражаем адаптерам для управляемых портов, это позволяет тестировать приложение изолированно.</p>
	<h1>2.5. РЕЗЮМЕ</h1>
			<p>Как мы видели, элементами архитектуры являются:</p>
	<ul>
		<li>Гексагон ==> приложение</li>
		<ul>
			<li>Управляющие поры ==> API, предлагаемый приложением</li>
			<li>Управляемые порты ==> SPI, требуемые приложением</li>
		</ul>
		<li>Акторы ==> устройства среды, которые взаимодействуют с приложением</li>
		<ul>
			<li>Драйверы ==> пользователи приложения (либо люди, либо аппаратные/программные устройства)</li>
			<li>Управляемые акторы ==> предоставляют услуги, необходимые приложению</li>
		</ul>
		<li>Адаптеры ==> адаптируют конкретную технологию к приложению</li>
		<ul>
			<li>Управляющие адаптеры ==> используют порты драйверов</li>
			<li>Управляемые адаптеры ==> реализуют управляемые порты</li>
		</ul>
	</ul>
		<p>Кроме этих элементов, будет существовать корень композиции (Composition Root) (также называемый главным компонентом Робертом К. Мартином в его книге "Чистая архитектура: A Craftsman's Guide to Software Structure and Design). Этот компонент будет запускаться при запуске, и он создает всю систему, делая следующее:</p>
	<ol>
		<li>Инициализирует и настраивает среду (базы данных, серверы, ...).</li>
		<li>Для каждого управляемого порта он выбирает управляемый адаптер, реализующий этот порт, и создает экземпляр адаптера.</li>
		<li>Создает экземпляр приложения, инжектируя экземпляры управляемых адаптеров в конструктор приложения.</li>
		<li>Для каждого порта драйвера:</li>
		 <ul>
		 	<li>Выбирается адаптер драйвера, использующий порт, и создается экземпляр адаптера, инжектируют экземпляр приложения в конструктор адаптера.</li>
		 	<li>Запускает экземпляр адаптера драйвера.</li>
		 </ul>
	</ol>
	<h1>2.6- ПРИМЕР</h1>
		<p>Простое приложение с веб-интерфейсом, используемое сотрудниками компании для назначения задач друг другу. Когда сотрудник получает задание, приложение отправляет ему/ей электронное письмо.</p>
	<center> <img src="img_4.jpeg"> </center>
	        <p><center>Рисунок 4: Пример (приложение "Назначение задач")</center></p>	
<footer>
	<p><a href="index.html"> Назад к оглавлению </a> </p>
</footer>
</body>
</html>
